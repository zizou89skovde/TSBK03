#version 400

#define NUM_OF_GRASS_VERTICES 5

layout (triangles, invocations = 2) in;
layout (triangle_strip, max_vertices = NUM_OF_GRASS_VERTICES) out;

uniform sampler2D u_GrassMask;
uniform sampler2D u_GrassNoise;

uniform mat4 VP_Matrix;
uniform mat4 V_Matrix;
uniform mat4 P_Matrix;

in vec2 g_TextureCoord[3];
in float g_Height[3];

out vec3 f_Normal;

void createGrassStraw(inout vec3 grassVertices[NUM_OF_GRASS_VERTICES]);
void createNormals(inout vec3 grassNormals[NUM_OF_GRASS_VERTICES], in vec3 grassVertices[NUM_OF_GRASS_VERTICES]);
void getPosition(inout vec3 position, inout float height, inout vec2 texCoord);
void rotateGrass(inout vec3 grassVertices[NUM_OF_GRASS_VERTICES], in float theta, in vec3 position, in float height);

void main()
{
	/* Get  position in a triangle (In world coordinates) */
	vec3 position = vec3(0.0);
	float height = 0;
	vec2 texCoord = vec2(0.0);
	getPosition(position, height, texCoord);

	/* Read grass mask from texture, returns value between 0 and 1 */
	float grassMask = texture(u_GrassMask, texCoord).x;

	/* Read grass noise from texture, returns value between 0 and 1 */
	float grassNoise = texture(u_GrassNoise, texCoord).x;
	if (gl_InvocationID == 1) {
		height += 10;
	}
	/* Create grass straw */
	vec3 grassVertices[NUM_OF_GRASS_VERTICES] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
	createGrassStraw(grassVertices);

	/* Create normals*/
	vec3 grassNormals[NUM_OF_GRASS_VERTICES] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
	createNormals(grassNormals, grassVertices);

	/* Rotate grass with angle theta */
	float pi = 3.1415;
	float theta;
	if (grassNoise > 0.5) {
		theta = 0; //grassNoise * pi/4;
	}
	else {
		theta = pi/2; //grassNoise * pi/2;
	}
	rotateGrass(grassVertices, theta, position, height);

	/* Transform grass to screen */
	for (int i = 0; i < NUM_OF_GRASS_VERTICES; ++i) {
		vec4 fragPos = VP_Matrix*vec4(grassVertices[i], 1.0); 
		f_Normal = grassNormals[i];
		if (grassMask < 0.5) {
			fragPos.w = -1.0;
		}
		gl_Position = fragPos;
		EmitVertex();
	}
	EndPrimitive();
}

void getPosition(inout vec3 position, inout float height, inout vec2 texCoord)
{
	for (int i = 0; i < 3; ++i) {
		position += gl_in[i].gl_Position.xyz; 
		height += g_Height[i];
		texCoord += g_TextureCoord[i];
	}
	position /= 3.0;
	height /= 3.0;
	texCoord /= 3.0;
}

void createGrassStraw(inout vec3 grassVertices[NUM_OF_GRASS_VERTICES])
{
	/* Define grass properties */
	float grassBaseWidth = 0.5; //0.05;
	float grassDeltaHeight = 2.5; //0.25;
	float grassDeltaZ = 1.5; //0.15;

	for (int i = 0; i < NUM_OF_GRASS_VERTICES; ++i) {
		/* Special case for first vertice - On ground level */
		if (i == 0) {
			grassVertices[i] = vec3(0.0);
		}
		else if (i == NUM_OF_GRASS_VERTICES - 1) {
			grassVertices[i] = vec3(0.0, grassDeltaHeight*(i - 1), grassDeltaZ);
		}
		/* i is odd */
		else if (mod(i, 2) == 1) {
			grassVertices[i] = vec3(grassBaseWidth, grassDeltaHeight*(i - 1), 0.0);
		}
		/* i is even */
		else {
			grassVertices[i] = vec3(0.0, grassDeltaHeight*(i - 1), 0.0);
		}
	}
}

void createNormals(inout vec3 grassNormals[NUM_OF_GRASS_VERTICES], in vec3 grassVertices[NUM_OF_GRASS_VERTICES])
{
	/* Brute force vectors */
	vec3 grassVerticesVector01 = grassVertices[1] - grassVertices[0];
	vec3 grassVerticesVector10 = -grassVerticesVector01;
	vec3 grassVerticesVector12 = grassVertices[2] - grassVertices[1];
	vec3 grassVerticesVector21 = -grassVerticesVector12;
	vec3 grassVerticesVector02 = grassVertices[2] - grassVertices[0];
	vec3 grassVerticesVector20 = grassVerticesVector02;
	vec3 grassVerticesVector23 = grassVertices[3] - grassVertices[2];
	vec3 grassVerticesVector32 = -grassVerticesVector23;
	vec3 grassVerticesVector31 = grassVertices[3] - grassVertices[1];
	vec3 grassVerticesVector13 = -grassVerticesVector31;
	vec3 grassVerticesVector34 = grassVertices[4] - grassVertices[3];
	vec3 grassVerticesVector43 = -grassVerticesVector34;
	vec3 grassVerticesVector24 = grassVertices[4] - grassVertices[2];
	vec3 grassVerticesVector42 = -grassVerticesVector24;
	
	/* Create normals */
	grassNormals[0] = normalize(cross(grassVerticesVector01, grassVerticesVector02));
	grassNormals[1] = (normalize(cross(grassVerticesVector13, grassVerticesVector12)) + normalize(cross(grassVerticesVector12, grassVerticesVector10)))/2.0;
	grassNormals[2] = (normalize(cross(grassVerticesVector20, grassVerticesVector21)) + normalize(cross(grassVerticesVector21, grassVerticesVector23)) + normalize(cross(grassVerticesVector23, grassVerticesVector24)))/3.0;
	grassNormals[3] = (normalize(cross(grassVerticesVector34, grassVerticesVector32)) + normalize(cross(grassVerticesVector32, grassVerticesVector31)))/2.0;
	grassNormals[4] = normalize(cross(grassVerticesVector42, grassVerticesVector43));
}

void rotateGrass(inout vec3 grassVertices[NUM_OF_GRASS_VERTICES], in float theta, in vec3 position, in float height)
{
	mat3 rotationMatrix = mat3(cos(theta), 0.0, sin(theta), 0.0, 1.0, 0.0, -sin(theta), 0.0, cos(theta));

	for (int i = 0; i < NUM_OF_GRASS_VERTICES; ++i) {
		grassVertices[i] = rotationMatrix*grassVertices[i];
		grassVertices[i] += position;
		grassVertices[i].y += height;
	}
}

